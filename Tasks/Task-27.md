Following the structured plan, we proceed with **Task 27: Agreements/Licensing Retrieve/Download Signed PDF**.

This task finalizes the legal documentation lifecycle by implementing the secure endpoint for retrieving the signed agreement, utilizing the Asset Service for pre-signed download URLs.

***

## **Task 27: Agreements/Licensing Retrieve/Download Signed PDF**

**Goal:** Implement the endpoint (`GET /agreements/:id/pdf`) to retrieve the signed PDF, checking if the final PDF asset is available, and returning a time-limited, pre-signed download URL (via Asset Service's logic).

**Service:** `Agreements & Licensing Service`
**Phase:** D - Agreements, Licensing & Audit foundations
**Dependencies:** Task 26 (Agreement Model, Signing Logic), Task 20 (Asset Service - `getAssetAndSignedDownloadUrl` dependency), Task 2 (RBAC Middleware).

**Output Files:**
1.  `src/services/agreement.service.ts` (Updated: `getSignedPdfUrl`)
2.  `src/controllers/agreement.controller.ts` (Updated: `downloadPdfController`)
3.  `src/routes/agreement.routes.ts` (Updated: new protected route)
4.  `test/integration/agreement_pdf.test.ts` (Test specification)

**Input/Output Shapes:**

| Endpoint | Request (Params) | Response (200 OK/202 Accepted) | Access/Scope |
| :--- | :--- | :--- | :--- |
| **GET /agreements/:id/pdf** | `Params: { agreementId }` | `{ downloadUrl: string, downloadUrlExpiresAt: string }` | Auth (Signer/Member/Admin) |

**Success Response (PDF Ready):**
```json
{
  "downloadUrl": "https://s3.aws.com/signed-pdfs/...",
  "downloadUrlExpiresAt": "2025-11-01T12:35:00Z"
}
```

**Runtime & Env Constraints:**
*   **Security:** The system must ensure that only actual signers, project members, or Admins can access the final document.
*   **Decoupling:** The service must call the Asset Service (`getAssetAndSignedDownloadUrl`) to offload the security-sensitive URL generation.
*   **Asynchronicity:** If the PDF is still being generated by a worker (Task 55), the API should return **202 Accepted** to inform the client to check again later.

**Acceptance Criteria:**
*   A fully signed agreement with an available `pdfAssetId` returns **200 OK** with a valid download URL.
*   An attempt to download the PDF for a document that is not fully signed or is missing the `pdfAssetId` returns **202 Accepted** (or a 404/409, depending on the implementation's view of pending vs. missing). We will use **409 Conflict** for not-ready documents to be explicit.
*   Access must be restricted to signers, members, or admins (403 Forbidden).

**Tests to Generate:**
*   **Integration Test (Download Ready):** Test success for a member/signer.
*   **Integration Test (Download Pending):** Test failure (409) for a partially signed document.
*   **Integration Test (Security):** Test unauthorized user download attempt (403).

***

### **Task 27 Code Implementation**

#### **27.1. `src/services/agreement.service.ts` (Updates)**

```typescript
// src/services/agreement.service.ts (partial update)
// ... (Imports, AgreementModel, ISigner) ...
import { AssetService } from './asset.service'; // Dependency on Task 20/22
import { ProjectModel } from '../models/project.model';
import { IAuthUser } from '../middlewares/auth.middleware';

const assetService = new AssetService(); // Instantiate the Asset Service


export class AgreementService {
    // ... (generateAgreementDraft, completeSigning methods from Task 21/26) ...

    /** Checks if the requester is a Signer, Project Member, or Admin. @throws {Error} 'PermissionDenied' */
    private async checkDocumentAccess(agreement: IAgreement, requesterId: string, requesterRole: IAuthUser['role']): Promise<void> {
        const isSigner = agreement.signers.some(s => s.signerId?.toString() === requesterId || s.email === requesterId);
        const isAdmin = requesterRole === 'admin';
        
        // 1. Check Project Membership
        const project = await ProjectModel.findById(agreement.projectId).select('teamMemberIds').lean();
        const isMember = project?.teamMemberIds.some(id => id.toString() === requesterId) || false;

        if (!isSigner && !isMember && !isAdmin) {
            throw new Error('PermissionDenied');
        }
    }


    /** Retrieves the secure signed PDF download URL. */
    public async getSignedPdfUrl(agreementId: string, requesterId: string, requesterRole: IAuthUser['role']): Promise<any> {
        const agreementObjectId = new Types.ObjectId(agreementId);
        
        // 1. Fetch Agreement
        const agreement = await AgreementModel.findById(agreementObjectId).lean() as IAgreement;
        if (!agreement) { throw new Error('AgreementNotFound'); }

        // 2. Authorization Check
        await this.checkDocumentAccess(agreement, requesterId, requesterRole);

        // 3. Status Check (Must be fully signed and PDF asset generated)
        if (agreement.status !== 'signed') {
            throw new Error('DocumentNotFinalized'); // Explicit 409 conflict
        }
        if (!agreement.pdfAssetId) {
            // Document is signed, but PDF generation job (Task 55) has not completed yet
            throw new Error('PdfAssetPending'); // Explicit 409 conflict/202 accepted
        }

        // 4. Retrieve Signed URL from Asset Service (Decoupling)
        // AssetService.getAssetAndSignedDownloadUrl already performs access checks, but we trust it to return a secure URL
        const assetDetails = await assetService.getAssetAndSignedDownloadUrl(
            agreement.pdfAssetId.toString(), 
            requesterId, 
            requesterRole, 
            true // Ensure presign is true
        );
        
        // 5. Return Download DTO
        return {
            downloadUrl: assetDetails.downloadUrl,
            downloadUrlExpiresAt: assetDetails.downloadUrlExpiresAt,
            filename: `Agreement-${agreement.agreementId}.pdf`,
        };
    }
}```

#### **27.2. `src/controllers/agreement.controller.ts` (Updates)**

```typescript
// src/controllers/agreement.controller.ts (partial update)
// ... (Imports, agreementService initialization, all previous controllers) ...

/** Handles the agreement PDF download request. GET /agreements/:id/pdf */
export const downloadPdfController = async (req: Request, res: Response) => {
    // 1. Input Validation
    if (!validationResult(req).isEmpty()) { return res.status(422).json({ error: { code: 'validation_error', message: 'Invalid ID format.' }}); }
    
    try {
        const { agreementId } = req.params;
        const requesterId = req.user!.sub; 

        // 2. Service Call
        const downloadData = await agreementService.getSignedPdfUrl(agreementId, requesterId, req.user!.role);

        // 3. Success (200 OK)
        return res.status(200).json(downloadData);

    } catch (error: any) {
        // 4. Error Handling
        if (error.message === 'PermissionDenied') { return res.status(403).json({ error: { code: 'access_denied', message: 'You are not authorized to download this agreement.' } }); }
        if (error.message === 'AgreementNotFound') { return res.status(404).json({ error: { code: 'agreement_not_found', message: 'Agreement not found.' } }); }
        if (error.message === 'DocumentNotFinalized' || error.message === 'PdfAssetPending') { 
            // Use 409 Conflict to indicate document exists but is not in the final, ready-to-download state
            return res.status(409).json({ error: { code: 'document_not_ready', message: 'Document is not yet fully signed or the final PDF is still being generated.' } }); 
        }
        
        return res.status(500).json({ error: { code: 'server_error', message: 'Internal server error retrieving PDF.' } });
    }
};
```

#### **27.3. `src/routes/agreement.routes.ts` (Updates)**

```typescript
// src/routes/agreement.routes.ts (partial update)
import { Router } from 'express';
// ... (Imports from Task 21/26) ...
import { downloadPdfController } from '../controllers/agreement.controller';
import { authenticate } from '../middlewares/auth.middleware'; 
import { param } from 'express-validator';

const router = Router();
const agreementIdParamValidation = [param('agreementId').isString().withMessage('Agreement ID is required.').bail()];

// ... (POST /projects/:id/agreements/generate from Task 21) ...
// ... (POST /agreements/:id/sign from Task 26) ...


// --- Agreements Download Endpoint (Task 27) ---

// GET /agreements/:agreementId/pdf - Download the signed PDF
router.get(
    '/:agreementId/pdf',
    authenticate,
    agreementIdParamValidation,
    // NOTE: Access control is handled in the service (Signer/Member/Admin)
    downloadPdfController
);


export default router;
```

#### **27.4. Test Specification**

| Test ID | Endpoint | Description | Condition | Expected Status | Expected Code |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **T27.1** | `GET /:id/pdf` | Happy Path: Ready Document | Auth Signer, `status: signed`, `pdfAssetId: present` | **200 OK** | N/A (`downloadUrl` is present) |
| **T27.2** | `GET /:id/pdf` | Fail: Not Signed | Auth Signer, `status: partially_signed` | **409 Conflict** | `document_not_ready` |
| **T27.3** | `GET /:id/pdf` | Fail: Asset Pending | Auth Signer, `status: signed`, `pdfAssetId: null` | **409 Conflict** | `document_not_ready` |
| **T27.4** | `GET /:id/pdf` | Fail: Not Authorized | Auth Non-Signer/Non-Member | **403 Forbidden** | `access_denied` |

---

